<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Casino Platform ‚Äî Play & Win</title>
    <meta name="description"
        content="Premium crypto casino platform. Play Dice, Coin Flip, Roulette, and Bomb Yard with fair odds.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=Syne:wght@600;700;800&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a12;
            --bg-secondary: rgba(255, 255, 255, 0.04);
            --bg-card: rgba(255, 255, 255, 0.06);
            --bg-glass: rgba(255, 255, 255, 0.08);
            --text-primary: #f0f0f5;
            --text-secondary: rgba(255, 255, 255, 0.55);
            --text-tertiary: rgba(255, 255, 255, 0.3);
            --accent: #00e87b;
            --accent-glow: rgba(0, 232, 123, 0.3);
            --accent-dark: #00c466;
            --purple: #7c3aed;
            --purple-glow: rgba(124, 58, 237, 0.25);
            --border: rgba(255, 255, 255, 0.08);
            --error: #ff4757;
            --success: #00e87b;
            --gold: #fbbf24;
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            padding-bottom: 100px;
            -webkit-font-smoothing: antialiased;
            overflow-x: hidden;
        }

        /* Animated gradient orbs */
        body::before,
        body::after {
            content: '';
            position: fixed;
            border-radius: 50%;
            filter: blur(120px);
            opacity: 0.4;
            z-index: -1;
            pointer-events: none;
            animation: orbFloat 12s ease-in-out infinite alternate;
        }

        body::before {
            width: 350px;
            height: 350px;
            background: var(--purple);
            top: -80px;
            left: -80px;
        }

        body::after {
            width: 300px;
            height: 300px;
            background: var(--accent);
            bottom: 10%;
            right: -60px;
            animation-delay: -6s;
        }

        @keyframes orbFloat {
            0% {
                transform: translate(0, 0) scale(1);
            }

            100% {
                transform: translate(40px, 30px) scale(1.15);
            }
        }

        /* Header */
        .header {
            background: rgba(10, 10, 18, 0.85);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border-bottom: 1px solid var(--border);
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-family: 'Syne', sans-serif;
            font-size: 22px;
            font-weight: 800;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent), var(--purple));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .balance-display {
            font-weight: 700;
            font-size: 14px;
            padding: 8px 14px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .lang-switch {
            padding: 8px 12px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-primary);
        }

        .lang-switch:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        /* Container */
        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 16px;
        }

        /* Bottom Nav */
        .bottom-nav {
            position: fixed;
            bottom: 12px;
            left: 12px;
            right: 12px;
            max-width: 460px;
            margin: 0 auto;
            background: rgba(20, 20, 35, 0.92);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid var(--border);
            border-radius: 20px;
            display: flex;
            justify-content: space-around;
            padding: 8px 4px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            padding: 8px 4px;
            cursor: pointer;
            background: none;
            border: none;
            color: var(--text-tertiary);
            font-size: 10px;
            font-weight: 600;
            transition: all 0.25s;
            border-radius: 12px;
        }

        .nav-item.active {
            color: var(--accent);
            background: var(--accent-glow);
        }

        .nav-item:hover {
            color: var(--text-primary);
        }

        .nav-icon {
            width: 22px;
            height: 22px;
        }

        /* Screens */
        .screen {
            display: none;
        }

        .screen.active {
            display: block;
            animation: screenIn 0.35s cubic-bezier(0.22, 1, 0.36, 1);
        }

        @keyframes screenIn {
            from {
                opacity: 0;
                transform: translateY(16px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Welcome Hero */
        .welcome-section {
            background: linear-gradient(145deg, rgba(124, 58, 237, 0.2), rgba(0, 232, 123, 0.08));
            border-radius: 24px;
            padding: 36px 24px;
            margin-bottom: 28px;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .welcome-section::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -30%;
            width: 200px;
            height: 200px;
            background: var(--purple);
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.3;
        }

        .welcome-title {
            font-family: 'Syne', sans-serif;
            font-size: 30px;
            font-weight: 800;
            margin-bottom: 8px;
            line-height: 1.15;
            position: relative;
        }

        .welcome-subtitle {
            color: var(--text-secondary);
            font-size: 15px;
            margin-bottom: 24px;
            position: relative;
        }

        .cta-button {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: #000;
            border: none;
            border-radius: 14px;
            font-size: 15px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.25s;
            position: relative;
            letter-spacing: 0.03em;
            text-transform: uppercase;
            box-shadow: 0 4px 24px var(--accent-glow);
        }

        .cta-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 32px var(--accent-glow);
        }

        .cta-button:active {
            transform: scale(0.98);
        }

        /* Section Titles */
        .section-title {
            font-family: 'Syne', sans-serif;
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 16px;
        }

        /* Game Cards */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        .game-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 24px 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .game-card::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 20px;
            background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.03));
            pointer-events: none;
        }

        .game-card:hover {
            transform: translateY(-4px);
            border-color: var(--accent);
            box-shadow: 0 8px 30px rgba(0, 232, 123, 0.1);
        }

        .game-card:active {
            transform: scale(0.97);
        }

        .game-icon {
            width: 52px;
            height: 52px;
            margin: 0 auto 12px;
            background: linear-gradient(135deg, var(--purple-glow), var(--accent-glow));
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
        }

        .game-name {
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 4px;
        }

        .game-edge {
            color: var(--text-tertiary);
            font-size: 11px;
            font-weight: 500;
        }

        /* Game Container */
        .game-container {
            background: var(--bg-card);
            border-radius: 24px;
            padding: 20px;
            border: 1px solid var(--border);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-button {
            padding: 8px 16px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .game-title {
            font-family: 'Syne', sans-serif;
            font-size: 20px;
            font-weight: 700;
        }

        /* 3D Dice Cube */
        .dice-scene {
            width: 120px;
            height: 120px;
            perspective: 600px;
            margin: 24px auto;
        }

        .dice-cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(-25deg) rotateY(25deg);
            transition: transform 0.15s ease-out;
        }

        .dice-cube.rolling {
            animation: diceRoll 1.2s cubic-bezier(0.2, 0.8, 0.3, 1);
        }

        @keyframes diceRoll {
            0% {
                transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
            }

            15% {
                transform: rotateX(200deg) rotateY(130deg) rotateZ(80deg);
            }

            30% {
                transform: rotateX(400deg) rotateY(270deg) rotateZ(160deg);
            }

            50% {
                transform: rotateX(620deg) rotateY(450deg) rotateZ(250deg);
            }

            70% {
                transform: rotateX(810deg) rotateY(580deg) rotateZ(310deg);
            }

            85% {
                transform: rotateX(940deg) rotateY(680deg) rotateZ(350deg);
            }

            100% {
                transform: var(--dice-final-transform);
            }
        }

        .dice-face {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 16px;
            background: linear-gradient(145deg, #1e1e3a, #14142a);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 0 20px rgba(0, 232, 123, 0.05), 0 0 15px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            backface-visibility: visible;
        }

        .dice-face-num {
            font-family: 'Syne', sans-serif;
            font-size: 48px;
            font-weight: 800;
            color: #00e87b;
            text-shadow: 0 0 12px rgba(0, 232, 123, 0.5);
        }

        .dice-face-front {
            transform: rotateY(0deg) translateZ(60px);
        }

        .dice-face-back {
            transform: rotateY(180deg) translateZ(60px);
        }

        .dice-face-left {
            transform: rotateY(-90deg) translateZ(60px);
        }

        .dice-face-right {
            transform: rotateY(90deg) translateZ(60px);
        }

        .dice-face-top {
            transform: rotateX(90deg) translateZ(60px);
        }

        .dice-face-bottom {
            transform: rotateX(-90deg) translateZ(60px);
        }

        .dice-result-number {
            text-align: center;
            font-family: 'Syne', sans-serif;
            font-size: 42px;
            font-weight: 800;
            margin: 8px 0 4px;
            height: 52px;
            background: linear-gradient(135deg, var(--accent), #fff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dice-result-number.visible {
            opacity: 1;
        }

        /* Faces selector */
        .dice-faces-selector {
            margin: 20px 0;
        }

        .dice-faces-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 14px;
        }

        .dice-faces-value {
            color: var(--accent);
            font-family: 'Syne', sans-serif;
            font-weight: 800;
        }

        /* Face Picker Grid */
        .face-picker {
            margin: 16px 0;
        }

        .face-picker-label {
            font-weight: 600;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .face-picker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(52px, 1fr));
            gap: 8px;
        }

        .face-pick-btn {
            padding: 12px 8px;
            background: var(--bg-glass);
            border: 2px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-family: 'Syne', sans-serif;
            font-size: 18px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .face-pick-btn:hover {
            border-color: rgba(0, 232, 123, 0.4);
            background: rgba(0, 232, 123, 0.08);
        }

        .face-pick-btn.selected {
            border-color: var(--accent);
            background: rgba(0, 232, 123, 0.15);
            color: var(--accent);
            box-shadow: 0 0 16px rgba(0, 232, 123, 0.2);
        }

        /* Dice Slider */
        .chance-slider-container {
            margin: 28px 0;
        }

        .chance-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 14px;
        }

        .chance-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, var(--accent), var(--purple));
            border-radius: 3px;
            outline: none;
        }

        .chance-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Multiplier */
        .multiplier-display {
            text-align: center;
            margin: 24px 0;
            padding: 20px;
            background: linear-gradient(145deg, rgba(124, 58, 237, 0.12), rgba(0, 232, 123, 0.06));
            border-radius: 16px;
            border: 1px solid var(--border);
        }

        .multiplier-label {
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 4px;
        }

        .multiplier-value {
            font-family: 'Syne', sans-serif;
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent), #fff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Bet Controls */
        .bet-controls {
            margin-top: 24px;
        }

        .bet-input-group {
            margin-bottom: 12px;
        }

        .bet-label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .bet-input {
            width: 100%;
            padding: 14px;
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 17px;
            font-weight: 700;
            background: var(--bg-glass);
            color: var(--text-primary);
            transition: border-color 0.2s;
        }

        .bet-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .quick-bets {
            display: flex;
            gap: 6px;
            margin-bottom: 14px;
        }

        .quick-bet-button {
            flex: 1;
            padding: 10px;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 10px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-primary);
        }

        .quick-bet-button:hover {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .play-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: #000;
            border: none;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.25s;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            box-shadow: 0 4px 20px var(--accent-glow);
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 28px var(--accent-glow);
        }

        .play-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Coin Flip */
        .coin-options {
            display: flex;
            gap: 12px;
            margin: 28px 0;
        }

        .coin-option {
            flex: 1;
            padding: 40px 16px;
            background: var(--bg-glass);
            border: 2px solid var(--border);
            border-radius: 20px;
            cursor: pointer;
            text-align: center;
            font-size: 44px;
            transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .coin-option:hover {
            border-color: var(--purple);
            transform: scale(1.04);
        }

        .coin-option.selected {
            background: linear-gradient(145deg, rgba(124, 58, 237, 0.3), rgba(0, 232, 123, 0.15));
            border-color: var(--accent);
            box-shadow: 0 0 24px var(--accent-glow);
        }

        /* Roulette */
        .roulette-wheel {
            width: 100%;
            max-width: 260px;
            aspect-ratio: 1;
            margin: 24px auto;
            background: linear-gradient(145deg, rgba(124, 58, 237, 0.15), var(--bg-glass));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 56px;
            border: 3px solid var(--border);
            box-shadow: 0 0 40px var(--purple-glow);
            transition: transform 1.2s cubic-bezier(0.22, 1, 0.36, 1);
        }

        .roulette-bets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .roulette-bet-button {
            padding: 20px 12px;
            border: 2px solid var(--border);
            border-radius: 16px;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.25s;
            background: var(--bg-glass);
            color: var(--text-primary);
        }

        .roulette-bet-button.red {
            border-color: rgba(255, 71, 87, 0.5);
        }

        .roulette-bet-button.black {
            border-color: rgba(255, 255, 255, 0.2);
        }

        .roulette-bet-button.green {
            border-color: rgba(0, 232, 123, 0.4);
        }

        .roulette-bet-button:hover {
            transform: scale(1.04);
        }

        .roulette-bet-button.selected.red {
            background: #ff4757;
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 71, 87, 0.3);
        }

        .roulette-bet-button.selected.black {
            background: #2d2d3f;
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
        }

        .roulette-bet-button.selected.green {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 20px var(--accent-glow);
        }

        /* Bomb Grid */
        .bomb-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin: 24px 0;
        }

        .bomb-tile {
            aspect-ratio: 1;
            background: var(--bg-glass);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.25s;
        }

        .bomb-tile:hover:not(.revealed) {
            background: rgba(255, 255, 255, 0.12);
            transform: scale(1.06);
        }

        .bomb-tile.revealed {
            cursor: default;
        }

        .bomb-tile.safe {
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            border-color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        .bomb-tile.bomb {
            background: linear-gradient(135deg, #ff4757, #c0392b);
            border-color: #ff4757;
            box-shadow: 0 0 12px rgba(255, 71, 87, 0.3);
        }

        .bomb-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 14px;
            background: var(--bg-glass);
            border-radius: 16px;
            border: 1px solid var(--border);
        }

        .bomb-stat {
            text-align: center;
            flex: 1;
        }

        .bomb-stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .bomb-stat-value {
            font-size: 18px;
            font-weight: 700;
        }

        .cashout-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, var(--gold), #f59e0b);
            border: none;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 800;
            cursor: pointer;
            margin-bottom: 14px;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.3);
            transition: all 0.25s;
        }

        .cashout-button:hover {
            transform: translateY(-2px);
        }

        .cashout-button:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Wallet */
        .wallet-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .balance-card {
            text-align: center;
            padding: 28px 20px;
            background: linear-gradient(145deg, rgba(124, 58, 237, 0.15), rgba(0, 232, 123, 0.06));
            border-radius: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .balance-label {
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 6px;
        }

        .balance-amount {
            font-family: 'Syne', sans-serif;
            font-size: 42px;
            font-weight: 800;
            background: linear-gradient(135deg, #fff, var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .wallet-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .wallet-button {
            padding: 14px;
            border: 1px solid var(--accent);
            border-radius: 14px;
            background: transparent;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.25s;
            color: var(--accent);
            font-size: 14px;
        }

        .wallet-button:hover {
            background: var(--accent);
            color: #000;
        }

        .transaction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 0;
            border-bottom: 1px solid var(--border);
        }

        .transaction-item:last-child {
            border-bottom: none;
        }

        .transaction-info {
            flex: 1;
        }

        .transaction-type {
            font-weight: 600;
            margin-bottom: 3px;
            font-size: 14px;
        }

        .transaction-time {
            color: var(--text-tertiary);
            font-size: 11px;
        }

        .transaction-amount {
            font-weight: 700;
            font-size: 16px;
        }

        .transaction-amount.positive {
            color: var(--success);
        }

        .transaction-amount.negative {
            color: var(--error);
        }

        /* Referral */
        .referral-code-card {
            background: linear-gradient(145deg, rgba(124, 58, 237, 0.15), var(--bg-glass));
            padding: 24px;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        .referral-code {
            font-family: 'Syne', sans-serif;
            font-size: 28px;
            font-weight: 800;
            margin: 14px 0;
            letter-spacing: 0.12em;
            background: linear-gradient(135deg, var(--accent), var(--gold));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .copy-button {
            padding: 12px 28px;
            background: linear-gradient(135deg, var(--purple), #9333ea);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.25s;
            box-shadow: 0 4px 16px var(--purple-glow);
        }

        .copy-button:hover {
            transform: translateY(-2px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px;
            text-align: center;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-value {
            font-family: 'Syne', sans-serif;
            font-size: 22px;
            font-weight: 800;
        }

        .referral-tier {
            padding: 14px;
            background: var(--bg-glass);
            border-radius: 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .tier-info {
            font-weight: 600;
            font-size: 13px;
        }

        .tier-percentage {
            font-family: 'Syne', sans-serif;
            font-size: 18px;
            font-weight: 800;
            color: var(--accent);
        }

        /* Profile */
        .profile-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .profile-item {
            padding: 14px 0;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .profile-item:last-child {
            border-bottom: none;
        }

        .profile-label {
            font-weight: 600;
            font-size: 14px;
        }

        .profile-value {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* Result Modal */
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .result-modal.active {
            display: flex;
            animation: screenIn 0.35s;
        }

        .result-content {
            background: linear-gradient(160deg, #1a1a2e, #16162a);
            border-radius: 28px;
            padding: 40px 28px;
            text-align: center;
            max-width: 360px;
            width: 100%;
            border: 1px solid var(--border);
            box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
        }

        .result-emoji {
            font-size: 72px;
            margin-bottom: 12px;
        }

        .result-title {
            font-family: 'Syne', sans-serif;
            font-size: 28px;
            font-weight: 800;
            margin-bottom: 8px;
        }

        .result-amount {
            font-size: 40px;
            font-weight: 800;
            margin-bottom: 24px;
        }

        .result-amount.win {
            color: var(--success);
            text-shadow: 0 0 20px var(--accent-glow);
        }

        .result-amount.lose {
            color: var(--error);
        }

        .close-result-button {
            padding: 14px 40px;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: #000;
            border: none;
            border-radius: 14px;
            font-weight: 800;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.25s;
            box-shadow: 0 4px 16px var(--accent-glow);
        }

        .close-result-button:hover {
            transform: translateY(-2px);
        }

        /* Mersion Game Styles */
        .mersion-stations {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mersion-station {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg-glass);
            border: 2px solid var(--border);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.25s;
        }

        .mersion-station:hover {
            border-color: rgba(0, 150, 255, 0.5);
            background: rgba(0, 100, 200, 0.1);
        }

        .mersion-station.selected {
            border-color: #0096ff;
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.25), rgba(0, 232, 123, 0.1));
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.2);
        }

        .mersion-station-depth {
            font-family: 'Syne', sans-serif;
            font-weight: 800;
            font-size: 16px;
            color: #0096ff;
            min-width: 60px;
        }

        .mersion-station-name {
            flex: 1;
            font-weight: 600;
            font-size: 13px;
            color: var(--text-secondary);
            text-align: center;
        }

        .mersion-station-info {
            font-weight: 700;
            font-size: 12px;
            color: var(--text-tertiary);
            min-width: 50px;
            text-align: right;
        }

        .mersion-hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding: 12px;
            background: var(--bg-glass);
            border-radius: 16px;
            border: 1px solid var(--border);
        }

        .mersion-hud-item {
            text-align: center;
            flex: 1;
        }

        .mersion-hud-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 3px;
            letter-spacing: 0.08em;
        }

        .mersion-hud-value {
            font-family: 'Syne', sans-serif;
            font-size: 18px;
            font-weight: 800;
        }

        .mersion-ocean {
            position: relative;
            width: 100%;
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 1px solid rgba(0, 100, 200, 0.3);
            background: #020a18;
        }

        .mersion-ocean canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .mersion-progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 3px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .mersion-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0096ff, var(--accent));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .mersion-log {
            max-height: 110px;
            overflow-y: auto;
            padding: 6px 8px;
            background: var(--bg-glass);
            border-radius: 12px;
            border: 1px solid var(--border);
            font-size: 12px;
        }

        .mersion-log-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }

        .mersion-log-entry:last-child {
            border-bottom: none;
        }

        .mersion-log-positive {
            color: var(--accent);
            font-weight: 700;
        }

        .mersion-log-negative {
            color: var(--error);
            font-weight: 700;
        }
    </style>
</head>


<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">CASINO</div>
        <div class="header-actions">
            <div class="balance-display">
                <span style="font-size: 16px;">ü™ô</span> <span id="headerBalance">1000</span>
            </div>
            <button class="lang-switch" onclick="toggleLanguage()">
                <div style="display: flex; align-items: center; gap: 4px;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path
                            d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z">
                        </path>
                    </svg>
                    <span id="langText">EN</span>
                </div>
            </button>
        </div>
    </div>

    <!-- Container -->
    <div class="container">
        <!-- Home Screen -->
        <div id="homeScreen" class="screen active">
            <div class="welcome-section">
                <h1 class="welcome-title" data-en="Play Smart. Win Big." data-ru="–ò–≥—Ä–∞–π —É–º–Ω–æ. –í—ã–∏–≥—Ä—ã–≤–∞–π.">Play Smart.
                    Win Big.</h1>
                <p class="welcome-subtitle" data-en="Provably fair games" data-ru="–ß–µ—Å—Ç–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ-–∏–≥—Ä—ã">Provably
                    fair crypto games</p>
                <button class="cta-button" onclick="showScreen('gamesScreen')" data-en="Play Now"
                    data-ru="–ò–≥—Ä–∞—Ç—å —Å–µ–π—á–∞—Å">Play Now</button>
            </div>

            <h2 class="section-title" data-en="Popular Games" data-ru="–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –∏–≥—Ä—ã">Popular Games</h2>
            <div class="games-grid">
                <div class="game-card" onclick="showGame('dice')">
                    <div class="game-icon">üé≤</div>
                    <div class="game-name" data-en="Dice" data-ru="–ö–æ—Å—Ç–∏">Dice</div>
                </div>
                <div class="game-card" onclick="showGame('coinflip')">
                    <div class="game-icon">ü™ô</div>
                    <div class="game-name" data-en="Coin Flip" data-ru="–ú–æ–Ω–µ—Ç–∫–∞">Coin Flip</div>
                </div>
                <div class="game-card" onclick="showGame('roulette')">
                    <div class="game-icon">üé°</div>
                    <div class="game-name" data-en="Roulette" data-ru="–†—É–ª–µ—Ç–∫–∞">Roulette</div>
                </div>
                <div class="game-card" onclick="showGame('bombyard')">
                    <div class="game-icon">üí£</div>
                    <div class="game-name" data-en="Mines" data-ru="–ú–∏–Ω—ã">Mines</div>
                </div>
                <div class="game-card" onclick="showGame('mersion')" style="grid-column: 1 / -1;">
                    <div class="game-icon"
                        style="background: linear-gradient(135deg, rgba(0,100,200,0.4), rgba(0,232,123,0.2));">üêü</div>
                    <div class="game-name" data-en="Mersion" data-ru="–ú–µ—Ä—Å–∏–æ–Ω">Mersion</div>
                </div>
            </div>
        </div>

        <!-- Games Screen -->
        <div id="gamesScreen" class="screen">
            <h2 class="section-title" data-en="All Games" data-ru="–í—Å–µ –∏–≥—Ä—ã">All Games</h2>
            <div class="games-grid">
                <div class="game-card" onclick="showGame('dice')">
                    <div class="game-icon">üé≤</div>
                    <div class="game-name" data-en="Dice" data-ru="–ö–æ—Å—Ç–∏">Dice</div>
                </div>
                <div class="game-card" onclick="showGame('coinflip')">
                    <div class="game-icon">ü™ô</div>
                    <div class="game-name" data-en="Coin Flip" data-ru="–ú–æ–Ω–µ—Ç–∫–∞">Coin Flip</div>
                </div>
                <div class="game-card" onclick="showGame('roulette')">
                    <div class="game-icon">üé°</div>
                    <div class="game-name" data-en="Roulette" data-ru="–†—É–ª–µ—Ç–∫–∞">Roulette</div>
                </div>
                <div class="game-card" onclick="showGame('bombyard')">
                    <div class="game-icon">üí£</div>
                    <div class="game-name" data-en="Mines" data-ru="–ú–∏–Ω—ã">Mines</div>
                </div>
                <div class="game-card" onclick="showGame('mersion')" style="grid-column: 1 / -1;">
                    <div class="game-icon"
                        style="background: linear-gradient(135deg, rgba(0,100,200,0.4), rgba(0,232,123,0.2));">üêü</div>
                    <div class="game-name" data-en="Mersion" data-ru="–ú–µ—Ä—Å–∏–æ–Ω">Mersion</div>
                </div>
            </div>
        </div>

        <!-- Dice Game -->
        <div id="diceGame" class="screen">
            <div class="game-container">
                <div class="game-header">
                    <button class="back-button" onclick="showScreen('gamesScreen')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5"></path>
                            <path d="M12 19l-7-7 7-7"></path>
                        </svg>
                    </button>
                    <h2 class="game-title" data-en="Dice" data-ru="–ö–æ—Å—Ç–∏">Dice</h2>
                    <div style="width: 32px;"></div>
                </div>

                <!-- 3D Dice Cube -->
                <div class="dice-scene">
                    <div class="dice-cube" id="diceCube">
                        <div class="dice-face dice-face-front"><span class="dice-face-num" id="diceFaceFront">?</span>
                        </div>
                        <div class="dice-face dice-face-back"><span class="dice-face-num" id="diceFaceBack">?</span>
                        </div>
                        <div class="dice-face dice-face-left"><span class="dice-face-num" id="diceFaceLeft">?</span>
                        </div>
                        <div class="dice-face dice-face-right"><span class="dice-face-num" id="diceFaceRight">?</span>
                        </div>
                        <div class="dice-face dice-face-top"><span class="dice-face-num" id="diceFaceTop">?</span></div>
                        <div class="dice-face dice-face-bottom"><span class="dice-face-num" id="diceFaceBottom">?</span>
                        </div>
                    </div>
                </div>
                <div class="dice-result-number" id="diceResultNumber"></div>

                <!-- Number of Faces Selector -->
                <div class="dice-faces-selector">
                    <div class="dice-faces-label">
                        <span data-en="Number of Faces" data-ru="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥—Ä–∞–Ω–µ–π">Number of Faces</span>
                        <span class="dice-faces-value" id="diceFacesValue">6</span>
                    </div>
                    <input type="range" min="2" max="12" value="6" class="chance-slider" id="diceFacesSlider"
                        oninput="updateDiceFaces()">
                </div>

                <div class="multiplier-display">
                    <div class="multiplier-label" data-en="Multiplier" data-ru="–ú–Ω–æ–∂–∏—Ç–µ–ª—å">Multiplier</div>
                    <div class="multiplier-value" id="diceMultiplier">5.70x</div>
                </div>

                <!-- Face Picker -->
                <div class="face-picker">
                    <div class="face-picker-label" data-en="Pick Your Number" data-ru="–í—ã–±–µ—Ä–∏—Ç–µ —á–∏—Å–ª–æ">Pick Your Number
                    </div>
                    <div class="face-picker-grid" id="facePickerGrid"></div>
                </div>

                <div class="bet-controls">
                    <div class="bet-input-group">
                        <label class="bet-label" data-en="Bet Amount" data-ru="–°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏">Bet Amount</label>
                        <input type="number" class="bet-input" id="diceBet" value="1000" min="1">
                    </div>
                    <div class="quick-bets">
                        <button class="quick-bet-button"
                            onclick="document.getElementById('diceBet').value = 1000">1K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('diceBet').value = 5000">5K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('diceBet').value = 10000">10K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('diceBet').value = 50000">50K</button>
                    </div>
                    <button class="play-button" onclick="playDice()" data-en="Roll Dice" data-ru="–ë—Ä–æ—Å–∏—Ç—å –∫–æ—Å—Ç–∏">Roll
                        Dice</button>
                </div>
            </div>
        </div>

        <!-- Coin Flip Game -->
        <div id="coinflipGame" class="screen">
            <div class="game-container">
                <div class="game-header">
                    <button class="back-button" onclick="showScreen('gamesScreen')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5"></path>
                            <path d="M12 19l-7-7 7-7"></path>
                        </svg>
                    </button>
                    <h2 class="game-title" data-en="Coin Flip" data-ru="–ú–æ–Ω–µ—Ç–∫–∞">Coin Flip</h2>
                    <div style="width: 32px;"></div>
                </div>

                <div class="coin-options">
                    <div class="coin-option" id="headsOption" onclick="selectCoin('heads')">
                        <div style="font-size: 32px; margin-bottom: 8px;">ü¶Ö</div>
                        <div style="font-size: 12px; font-weight: 700; color: var(--text-secondary);">HEADS</div>
                    </div>
                    <div class="coin-option" id="tailsOption" onclick="selectCoin('tails')">
                        <div style="font-size: 32px; margin-bottom: 8px;">üåü</div>
                        <div style="font-size: 12px; font-weight: 700; color: var(--text-secondary);">TAILS</div>
                    </div>
                </div>

                <div class="multiplier-display">
                    <div class="multiplier-label" data-en="Multiplier" data-ru="–ú–Ω–æ–∂–∏—Ç–µ–ª—å">Punt Multiplier</div>
                    <div class="multiplier-value">2.00x</div>
                </div>

                <div class="bet-controls">
                    <div class="bet-input-group">
                        <label class="bet-label" data-en="Bet Amount" data-ru="–°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏">Bet Amount</label>
                        <input type="number" class="bet-input" id="coinBet" value="1000" min="1">
                    </div>
                    <div class="quick-bets">
                        <button class="quick-bet-button"
                            onclick="document.getElementById('coinBet').value = 1000">1K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('coinBet').value = 5000">5K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('coinBet').value = 10000">10K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('coinBet').value = 50000">50K</button>
                    </div>
                    <button class="play-button" onclick="playCoinFlip()" data-en="Flip Coin" data-ru="–ü–æ–¥–±—Ä–æ—Å–∏—Ç—å">Flip
                        Coin</button>
                </div>
            </div>
        </div>

        <!-- Roulette Game -->
        <div id="rouletteGame" class="screen">
            <div class="game-container">
                <div class="game-header">
                    <button class="back-button" onclick="showScreen('gamesScreen')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5"></path>
                            <path d="M12 19l-7-7 7-7"></path>
                        </svg>
                    </button>
                    <h2 class="game-title" data-en="Roulette" data-ru="–†—É–ª–µ—Ç–∫–∞">Roulette</h2>
                    <div style="width: 32px;"></div>
                </div>

                <div class="roulette-wheel" id="rouletteWheel">üé°</div>

                <div class="roulette-bets">
                    <button class="roulette-bet-button red" id="redBet" onclick="selectRoulette('red')">
                        <div data-en="Red" data-ru="–ö—Ä–∞—Å–Ω–æ–µ">RED</div>
                        <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;">2x</div>
                    </button>
                    <button class="roulette-bet-button green" id="greenBet" onclick="selectRoulette('green')">
                        <div data-en="Green" data-ru="–ó–µ–ª–µ–Ω–æ–µ">ZERO</div>
                        <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;">14x</div>
                    </button>
                    <button class="roulette-bet-button black" id="blackBet" onclick="selectRoulette('black')">
                        <div data-en="Black" data-ru="–ß–µ—Ä–Ω–æ–µ">BLACK</div>
                        <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;">2x</div>
                    </button>
                </div>

                <div class="bet-controls">
                    <div class="bet-input-group">
                        <label class="bet-label" data-en="Bet Amount" data-ru="–°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏">Bet Amount</label>
                        <input type="number" class="bet-input" id="rouletteBet" value="1000" min="1">
                    </div>
                    <div class="quick-bets">
                        <button class="quick-bet-button"
                            onclick="document.getElementById('rouletteBet').value = 1000">1K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('rouletteBet').value = 5000">5K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('rouletteBet').value = 10000">10K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('rouletteBet').value = 50000">50K</button>
                    </div>
                    <button class="play-button" onclick="playRoulette()" data-en="Spin Wheel" data-ru="–ö—Ä—É—Ç–∏—Ç—å">Spin
                        Wheel</button>
                </div>
            </div>
        </div>

        <!-- Bomb Yard Game -->
        <div id="bombyardGame" class="screen">
            <div class="game-container">
                <div class="game-header">
                    <button class="back-button" onclick="showScreen('gamesScreen')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5"></path>
                            <path d="M12 19l-7-7 7-7"></path>
                        </svg>
                    </button>
                    <h2 class="game-title" data-en="Mines" data-ru="–ú–∏–Ω—ã">Mines</h2>
                    <div style="width: 32px;"></div>
                </div>

                <div class="bomb-stats">
                    <div class="bomb-stat">
                        <div class="bomb-stat-label" data-en="Gems" data-ru="–ö–∞–º–Ω–∏">GEMS</div>
                        <div class="bomb-stat-value" id="bombPicks" style="color: var(--accent);">0</div>
                    </div>
                    <div class="bomb-stat">
                        <div class="bomb-stat-label" data-en="Multiplier" data-ru="–ú–Ω–æ–∂–∏—Ç–µ–ª—å">MULT</div>
                        <div class="bomb-stat-value" id="bombMultiplier">1.00x</div>
                    </div>
                    <div class="bomb-stat">
                        <div class="bomb-stat-label" data-en="Profit" data-ru="–ü—Ä–∏–±—ã–ª—å">PROFIT</div>
                        <div class="bomb-stat-value" id="bombWin">0</div>
                    </div>
                </div>

                <div class="bomb-grid" id="bombGrid"></div>

                <button class="cashout-button" id="bombCashout" onclick="cashoutBomb()" disabled data-en="Cashout"
                    data-ru="–ó–∞–±—Ä–∞—Ç—å">CASHOUT</button>

                <div class="bet-controls">
                    <div class="bet-input-group">
                        <label class="bet-label" data-en="Bet Amount" data-ru="–°—É–º–º–∞ —Å—Ç–∞–≤–∫–∏">Bet Amount</label>
                        <input type="number" class="bet-input" id="bombBet" value="1000" min="1">
                    </div>
                    <div class="quick-bets">
                        <button class="quick-bet-button"
                            onclick="document.getElementById('bombBet').value = 1000">1K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('bombBet').value = 5000">5K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('bombBet').value = 10000">10K</button>
                        <button class="quick-bet-button"
                            onclick="document.getElementById('bombBet').value = 50000">50K</button>
                    </div>
                    <button class="play-button" id="bombStart" onclick="startBomb()" data-en="Start Game"
                        data-ru="–ù–∞—á–∞—Ç—å">Start Game</button>
                </div>
            </div>
        </div>

        <!-- Mersion Game -->
        <div id="mersionGame" class="screen">
            <div class="game-container">
                <div class="game-header">
                    <button class="back-button" onclick="mersionBack()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5"></path>
                            <path d="M12 19l-7-7 7-7"></path>
                        </svg>
                    </button>
                    <h2 class="game-title" data-en="Mersion" data-ru="–ú–µ—Ä—Å–∏–æ–Ω">Mersion</h2>
                    <div style="width: 32px;"></div>
                </div>

                <!-- Setup Phase -->
                <div id="mersionSetup">
                    <div style="text-align:center; font-size:48px; margin-bottom:8px;">ü´ß</div>
                    <p style="color:var(--text-secondary); text-align:center; font-size:13px; margin-bottom:20px; line-height:1.5;"
                        data-en="Load coins into your submarine. Choose a depth zone. Fish with multipliers swim around ‚Äî when they hit your sub, your coins change. Deeper = more dangerous fish."
                        data-ru="–ó–∞–≥—Ä—É–∑–∏—Ç–µ –º–æ–Ω–µ—Ç—ã –≤ —Å—É–±–º–∞—Ä–∏–Ω—É. –í—ã–±–µ—Ä–∏—Ç–µ –∑–æ–Ω—É –≥–ª—É–±–∏–Ω—ã. –†—ã–±—ã —Å –º–Ω–æ–∂–∏—Ç–µ–ª—è–º–∏ –ø–ª–∞–≤–∞—é—Ç –≤–æ–∫—Ä—É–≥ ‚Äî –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏ –≤–∞—à–∏ –º–æ–Ω–µ—Ç—ã –º–µ–Ω—è—é—Ç—Å—è. –ì–ª—É–±–∂–µ = –æ–ø–∞—Å–Ω–µ–µ.">
                        Load coins into your submarine. Choose a depth zone. Fish with multipliers swim around ‚Äî when
                        they hit your sub, your coins change. Deeper = more dangerous fish.</p>

                    <div style="margin-bottom:16px;">
                        <label class="bet-label" data-en="Target Zone" data-ru="–¶–µ–ª–µ–≤–∞—è –∑–æ–Ω–∞">Target Zone</label>
                        <div class="mersion-stations" id="mersionStations">
                            <div class="mersion-station" onclick="selectStation(1)" data-station="1">
                                <div class="mersion-station-depth">200m</div>
                                <div class="mersion-station-name" data-en="Shallow Reef" data-ru="–†–∏—Ñ">Shallow Reef
                                </div>
                                <div class="mersion-station-info">4 fish</div>
                            </div>
                            <div class="mersion-station" onclick="selectStation(2)" data-station="2">
                                <div class="mersion-station-depth">500m</div>
                                <div class="mersion-station-name" data-en="Twilight Zone" data-ru="–°—É–º—Ä–∞–∫">Twilight Zone
                                </div>
                                <div class="mersion-station-info">7 fish</div>
                            </div>
                            <div class="mersion-station" onclick="selectStation(3)" data-station="3">
                                <div class="mersion-station-depth">1000m</div>
                                <div class="mersion-station-name" data-en="Midnight Zone" data-ru="–ë–µ–∑–¥–Ω–∞">Midnight Zone
                                </div>
                                <div class="mersion-station-info">10 fish</div>
                            </div>
                            <div class="mersion-station" onclick="selectStation(4)" data-station="4">
                                <div class="mersion-station-depth">3000m</div>
                                <div class="mersion-station-name" data-en="Abyssal Plain" data-ru="–ê–±–∏—Å—Å–∞–ª—å">Abyssal
                                    Plain</div>
                                <div class="mersion-station-info">14 fish</div>
                            </div>
                            <div class="mersion-station" onclick="selectStation(5)" data-station="5">
                                <div class="mersion-station-depth">6000m</div>
                                <div class="mersion-station-name" data-en="Hadal Trench" data-ru="–ú–∞—Ä–∏–∞–Ω–∫–∞">Hadal Trench
                                </div>
                                <div class="mersion-station-info">18 fish</div>
                            </div>
                        </div>
                    </div>

                    <div class="bet-controls">
                        <div class="bet-input-group">
                            <label class="bet-label" data-en="Coins in Submarine" data-ru="–ú–æ–Ω–µ—Ç—ã –≤ —Å—É–±–º–∞—Ä–∏–Ω—É">Coins in
                                Submarine</label>
                            <input type="number" class="bet-input" id="mersionBet" value="1000" min="1">
                        </div>
                        <div class="quick-bets">
                            <button class="quick-bet-button"
                                onclick="document.getElementById('mersionBet').value = 1000">1K</button>
                            <button class="quick-bet-button"
                                onclick="document.getElementById('mersionBet').value = 5000">5K</button>
                            <button class="quick-bet-button"
                                onclick="document.getElementById('mersionBet').value = 10000">10K</button>
                            <button class="quick-bet-button"
                                onclick="document.getElementById('mersionBet').value = 50000">50K</button>
                        </div>
                        <button class="play-button" id="mersionStartBtn" onclick="startMersion()" data-en="Dive!"
                            data-ru="–ü–æ–≥—Ä—É–∂–µ–Ω–∏–µ!">Dive!</button>
                    </div>
                </div>

                <!-- Dive Phase -->
                <div id="mersionDive" style="display:none;">
                    <div class="mersion-hud">
                        <div class="mersion-hud-item">
                            <div class="mersion-hud-label">COINS</div>
                            <div class="mersion-hud-value" id="mersionCoins" style="color:var(--accent);">1000</div>
                        </div>
                        <div class="mersion-hud-item">
                            <div class="mersion-hud-label">DEPTH</div>
                            <div class="mersion-hud-value" id="mersionDepth" style="color:#0096ff;">0m</div>
                        </div>
                        <div class="mersion-hud-item">
                            <div class="mersion-hud-label">HITS</div>
                            <div class="mersion-hud-value" id="mersionHits">0</div>
                        </div>
                    </div>

                    <div class="mersion-ocean" id="mersionOcean">
                        <canvas id="mersionCanvas"></canvas>
                    </div>

                    <div class="mersion-progress-bar">
                        <div class="mersion-progress-fill" id="mersionProgress" style="width:0%"></div>
                    </div>

                    <div class="mersion-log" id="mersionLog"></div>
                </div>
            </div>
        </div>

        <!-- Wallet Screen -->
        <div id="walletScreen" class="screen">
            <div class="wallet-section">
                <div class="balance-card">
                    <div class="balance-label" data-en="Total Balance" data-ru="–û–±—â–∏–π –±–∞–ª–∞–Ω—Å">TOTAL BALANCE</div>
                    <div class="balance-amount">ü™ô <span id="mainBalance">1000</span></div>
                    <div style="color: var(--text-secondary); font-size: 13px; margin-top: 8px; font-weight: 500;">‚âà
                        $<span id="usdBalance">10.00</span> USD</div>
                </div>
                <div class="wallet-actions">
                    <button class="wallet-button" data-en="Deposit" data-ru="–ü–æ–ø–æ–ª–Ω–∏—Ç—å"
                        onclick="alert('Deposit module loading...')">Deposit</button>
                    <button class="wallet-button" data-en="Withdraw" data-ru="–í—ã–≤–µ—Å—Ç–∏"
                        onclick="alert('Withdraw module loading...')">Withdraw</button>
                </div>
            </div>

            <div class="wallet-section">
                <h3 class="section-title" data-en="History" data-ru="–ò—Å—Ç–æ—Ä–∏—è">History</h3>
                <div id="transactionList">
                </div>
            </div>
        </div>

        <!-- Referrals Screen -->
        <div id="referralsScreen" class="screen">
            <div class="wallet-section">
                <h3 class="section-title" data-en="Affiliate" data-ru="–ü–∞—Ä—Ç–Ω–µ—Ä–∫–∞">Affiliate</h3>
                <div class="referral-code-card">
                    <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 8px;">YOUR CODE</div>
                    <div class="referral-code">LUCKY777</div>
                    <button class="copy-button" onclick="copyReferralCode()" data-en="Copy Link"
                        data-ru="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å">Copy Link</button>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label" data-en="Earnings" data-ru="–î–æ—Ö–æ–¥">Earnings</div>
                    <div class="stat-value">25K</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label" data-en="Friends" data-ru="–î—Ä—É–∑—å—è">Friends</div>
                    <div class="stat-value">12</div>
                </div>
            </div>

            <div class="wallet-section">
                <h3 class="section-title" data-en="Tiers" data-ru="–£—Ä–æ–≤–Ω–∏">Commission Tiers</h3>
                <div class="referral-tier">
                    <div class="tier-info">Tier 1</div>
                    <div class="tier-percentage">10%</div>
                </div>
                <div class="referral-tier">
                    <div class="tier-info">Tier 2</div>
                    <div class="tier-percentage">3%</div>
                </div>
            </div>
        </div>

        <!-- Profile Screen -->
        <div id="profileScreen" class="screen">
            <div class="profile-section">
                <div style="text-align: center; margin-bottom: 24px;">
                    <div
                        style="width: 80px; height: 80px; background: linear-gradient(135deg, var(--accent), var(--purple)); border-radius: 50%; margin: 0 auto 12px; display: flex; align-items: center; justify-content: center; font-size: 32px; font-weight: 800;">
                        C</div>
                    <h3 style="font-family: 'Syne'; font-size: 20px;">Player One</h3>
                    <div style="color: var(--text-secondary); font-size: 13px;">Level 12</div>
                </div>

                <div class="profile-item">
                    <div class="profile-label" data-en="Wallet" data-ru="–ö–æ—à–µ–ª–µ–∫">Wallet Connected</div>
                    <div class="profile-value" style="font-family: monospace;">0x74...4a8c</div>
                </div>
                <div class="profile-item">
                    <div class="profile-label" data-en="Language" data-ru="–Ø–∑—ã–∫">Language</div>
                    <div class="profile-value" style="color: var(--text-primary);"><span id="profileLang">English</span>
                    </div>
                </div>
            </div>

            <div class="profile-section">
                <div class="profile-item" onclick="alert('Support')" style="cursor: pointer;">
                    <div class="profile-label" data-en="Live Support" data-ru="–ü–æ–¥–¥–µ—Ä–∂–∫–∞">Live Support</div>
                    <div class="profile-value">‚Üí</div>
                </div>

            </div>
        </div>
    </div>

    <!-- Bottom Navigation -->
    <div class="bottom-nav">
        <button class="nav-item active" onclick="showScreen('homeScreen')">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9 22 9 12 15 12 15 22"></polyline>
            </svg>
            <span data-en="Lobby" data-ru="–õ–æ–±–±–∏">Lobby</span>
        </button>
        <button class="nav-item" onclick="showScreen('gamesScreen')">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                <line x1="8" y1="21" x2="16" y2="21"></line>
                <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
            <span data-en="Games" data-ru="–ò–≥—Ä—ã">Games</span>
        </button>
        <button class="nav-item" onclick="showScreen('walletScreen')">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect>
                <line x1="1" y1="10" x2="23" y2="10"></line>
            </svg>
            <span data-en="Wallet" data-ru="–ö–æ—à–µ–ª–µ–∫">Wallet</span>
        </button>
        <button class="nav-item" onclick="showScreen('referralsScreen')">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>
            <span data-en="Team" data-ru="–ö–æ–º–∞–Ω–¥–∞">Team</span>
        </button>
        <button class="nav-item" onclick="showScreen('profileScreen')">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
            </svg>
            <span data-en="Profile" data-ru="–ü—Ä–æ—Ñ–∏–ª—å">Profile</span>
        </button>
    </div>

    <!-- Result Modal -->
    <div class="result-modal" id="resultModal">
        <div class="result-content">
            <div class="result-emoji" id="resultEmoji">üéâ</div>
            <div class="result-title" id="resultTitle">You Won!</div>
            <div class="result-amount" id="resultAmount">+50 ü™ô</div>
            <button class="close-result-button" onclick="closeResult()">CONTINUE</button>
        </div>
    </div>

    <script>
        // Global state
        let balance = 1000; // Balance in game coins (1 coin = $0.01 USD)
        let currentLanguage = 'en';
        let selectedCoin = null;
        let selectedRoulette = null;
        let bombGame = null;
        let transactions = [];

        // Update balance display
        function updateBalance() {
            document.getElementById('headerBalance').textContent = Math.ceil(balance);
            document.getElementById('mainBalance').textContent = Math.ceil(balance);
            // Update USD equivalent in wallet only
            const usdBalanceEl = document.getElementById('usdBalance');
            if (usdBalanceEl) {
                usdBalanceEl.textContent = (balance * 0.01).toFixed(2);
            }
        }

        // Add transaction
        function addTransaction(game, amount, type) {
            const transaction = {
                game: game,
                amount: amount,
                type: type,
                time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
            };
            transactions.unshift(transaction);
            if (transactions.length > 20) transactions.pop(); // Keep last 20
            renderTransactions();
        }

        // Render transactions
        function renderTransactions() {
            const list = document.getElementById('transactionList');
            list.innerHTML = '';

            if (transactions.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: var(--text-tertiary); padding: 20px;">No transactions yet</div>';
                return;
            }

            transactions.forEach(tx => {
                const item = document.createElement('div');
                item.className = 'transaction-item';

                const amountClass = tx.amount > 0 ? 'positive' : 'negative';
                const amountSign = tx.amount > 0 ? '+' : '';

                item.innerHTML = `
                    <div class="transaction-info">
                        <div class="transaction-type">${tx.game}</div>
                        <div class="transaction-time">${tx.time}</div>
                    </div>
                    <div class="transaction-amount ${amountClass}">${amountSign}${Math.ceil(tx.amount)} ü™ô</div>
                `;

                list.appendChild(item);
            });
        }

        // Screen navigation
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');

            // Update nav active state
            document.querySelectorAll('.nav-item').forEach((item, index) => {
                item.classList.remove('active');
            });

            const navMap = {
                'homeScreen': 0,
                'gamesScreen': 1,
                'walletScreen': 2,
                'referralsScreen': 3,
                'profileScreen': 4
            };

            if (navMap[screenId] !== undefined) {
                document.querySelectorAll('.nav-item')[navMap[screenId]].classList.add('active');
            }
        }

        function showGame(gameId) {
            const gameMap = {
                'dice': 'diceGame',
                'coinflip': 'coinflipGame',
                'roulette': 'rouletteGame',
                'bombyard': 'bombyardGame',
                'mersion': 'mersionGame'
            };
            showScreen(gameMap[gameId]);
        }

        // Language toggle
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'en' ? 'ru' : 'en';
            document.getElementById('langText').textContent = currentLanguage.toUpperCase();

            // Update all translatable elements
            document.querySelectorAll('[data-en]').forEach(el => {
                el.textContent = el.getAttribute('data-' + currentLanguage);
            });

            // Update profile language display
            document.getElementById('profileLang').textContent = currentLanguage === 'en' ? 'English' : '–†—É—Å—Å–∫–∏–π';
        }

        // Dice game
        let diceFaces = 6;
        let dicePickedNumber = null;
        let diceRolling = false;

        function updateDiceFaces() {
            diceFaces = parseInt(document.getElementById('diceFacesSlider').value);
            document.getElementById('diceFacesValue').textContent = diceFaces;

            // Multiplier = faces (100% RTP ‚Äî no house edge)
            const multiplier = diceFaces;
            document.getElementById('diceMultiplier').textContent = multiplier.toFixed(2) + 'x';

            // Rebuild the face picker buttons
            buildFacePicker();

            // Reset cube face numbers
            updateCubeFaceNumbers();
        }

        function buildFacePicker() {
            const grid = document.getElementById('facePickerGrid');
            grid.innerHTML = '';
            dicePickedNumber = null;

            for (let i = 1; i <= diceFaces; i++) {
                const btn = document.createElement('button');
                btn.className = 'face-pick-btn';
                btn.textContent = i;
                btn.onclick = () => selectDiceFace(i);
                grid.appendChild(btn);
            }
        }

        function selectDiceFace(num) {
            if (diceRolling) return;
            dicePickedNumber = num;
            const buttons = document.querySelectorAll('.face-pick-btn');
            buttons.forEach(btn => {
                btn.classList.toggle('selected', parseInt(btn.textContent) === num);
            });
        }

        function updateCubeFaceNumbers() {
            // Put random numbers from the dice range on each cube face
            const ids = ['diceFaceFront', 'diceFaceBack', 'diceFaceLeft', 'diceFaceRight', 'diceFaceTop', 'diceFaceBottom'];
            ids.forEach(id => {
                document.getElementById(id).textContent = Math.floor(Math.random() * diceFaces) + 1;
            });
        }

        function playDice() {
            if (diceRolling) return;

            if (dicePickedNumber === null) {
                alert('Pick a number first!');
                return;
            }

            const betAmount = parseFloat(document.getElementById('diceBet').value);

            if (betAmount > balance) {
                alert('Insufficient balance!');
                return;
            }

            diceRolling = true;
            balance -= betAmount;
            updateBalance();

            // Roll a random number from 1 to diceFaces
            // Rigged: slight bias ‚Äî 10% chance the winning number is excluded
            let rolledNumber;
            if (Math.random() < 0.10) {
                // Force a losing roll
                const losers = [];
                for (let i = 1; i <= diceFaces; i++) {
                    if (i !== dicePickedNumber) losers.push(i);
                }
                rolledNumber = losers.length > 0 ? losers[Math.floor(Math.random() * losers.length)] : dicePickedNumber;
            } else {
                rolledNumber = Math.floor(Math.random() * diceFaces) + 1;
            }

            const win = (rolledNumber === dicePickedNumber);

            // Set random numbers on all 6 cube faces, but put the result on the front face
            const faceIds = ['diceFaceFront', 'diceFaceBack', 'diceFaceLeft', 'diceFaceRight', 'diceFaceTop', 'diceFaceBottom'];
            faceIds.forEach(id => {
                document.getElementById(id).textContent = Math.floor(Math.random() * diceFaces) + 1;
            });
            // The front face shows the result
            document.getElementById('diceFaceFront').textContent = rolledNumber;

            // Animate the cube
            const cube = document.getElementById('diceCube');
            const resultDisplay = document.getElementById('diceResultNumber');
            resultDisplay.classList.remove('visible');
            resultDisplay.textContent = '';

            // Always land on front face
            const finalTransform = 'rotateX(0deg) rotateY(0deg)';

            cube.style.setProperty('--dice-final-transform', finalTransform);
            cube.classList.remove('rolling');
            void cube.offsetWidth; // force reflow
            cube.classList.add('rolling');

            // Stage 1: Cube stops, show the rolled number
            setTimeout(() => {
                cube.classList.remove('rolling');
                cube.style.transform = finalTransform;
                resultDisplay.textContent = 'Rolled: ' + rolledNumber;
                resultDisplay.classList.add('visible');

                // Stage 2: After a pause, show the win/loss notification
                setTimeout(() => {
                    if (win) {
                        const multiplier = diceFaces;
                        const winAmount = betAmount * multiplier;
                        balance += winAmount;
                        showResult(true, winAmount - betAmount);
                        addTransaction('Dice', winAmount - betAmount, 'win');
                    } else {
                        showResult(false, betAmount);
                        addTransaction('Dice', -betAmount, 'loss');
                    }

                    updateBalance();
                    diceRolling = false;
                }, 1000);
            }, 1300);
        }

        // Coin flip game
        function selectCoin(side) {
            selectedCoin = side;
            document.getElementById('headsOption').classList.remove('selected');
            document.getElementById('tailsOption').classList.remove('selected');

            if (side === 'heads') {
                document.getElementById('headsOption').classList.add('selected');
            } else {
                document.getElementById('tailsOption').classList.add('selected');
            }
        }

        function playCoinFlip() {
            if (!selectedCoin) {
                alert('Select heads or tails!');
                return;
            }

            const betAmount = parseFloat(document.getElementById('coinBet').value);

            if (betAmount > balance) {
                alert('Insufficient balance!');
                return;
            }

            balance -= betAmount;
            updateBalance();

            // Win chance: 45% (Rigged: 5% lower than 50/50)
            const isWin = Math.random() < 0.45;

            // Determine result for internal consistency/logging if needed
            // If win, result matches selection. If loss, result is opposite.
            const result = isWin ? selectedCoin : (selectedCoin === 'heads' ? 'tails' : 'heads');
            const win = isWin;

            if (win) {
                const winAmount = betAmount * 2;
                balance += winAmount;
                showResult(true, winAmount - betAmount);
                addTransaction('Coin Flip', winAmount - betAmount, 'win');
            } else {
                showResult(false, betAmount);
                addTransaction('Coin Flip', -betAmount, 'loss');
            }

            updateBalance();
        }

        // Roulette game
        function selectRoulette(color) {
            selectedRoulette = color;
            document.getElementById('redBet').classList.remove('selected');
            document.getElementById('blackBet').classList.remove('selected');
            document.getElementById('greenBet').classList.remove('selected');

            document.getElementById(color + 'Bet').classList.add('selected');
        }

        function playRoulette() {
            if (!selectedRoulette) {
                alert('Select a color!');
                return;
            }

            const betAmount = parseFloat(document.getElementById('rouletteBet').value);

            if (betAmount > balance) {
                alert('Insufficient balance!');
                return;
            }

            balance -= betAmount;
            updateBalance();

            // Wheel: 18 red, 18 black, 2 green = 38 total
            const roll = Math.random() * 38;
            let result;

            // Rigged Logic for Red/Black: Force 45% win chance
            if (selectedRoulette === 'red' || selectedRoulette === 'black') {
                const isWin = Math.random() < 0.45;
                if (isWin) {
                    result = selectedRoulette;
                } else {
                    // Force a loss (pick opposite or green)
                    result = selectedRoulette === 'red' ? 'black' : 'red';
                    // Small chance for green to mimic real wheel behavior on loss
                    if (Math.random() < 0.05) result = 'green';
                }
            } else {
                // Standard logic for Green (or other bets if added)
                if (roll < 18) result = 'red';
                else if (roll < 36) result = 'black';
                else result = 'green';
            }

            // Animate wheel
            const wheel = document.getElementById('rouletteWheel');
            wheel.style.transform = 'rotate(720deg)';
            setTimeout(() => {
                wheel.style.transform = 'rotate(0deg)';
                wheel.textContent = result === 'red' ? 'üî¥' : result === 'black' ? '‚ö´' : 'üü¢';
            }, 1000);

            setTimeout(() => {
                const win = result === selectedRoulette;

                if (win) {
                    const multiplier = result === 'green' ? 14 : 2;
                    const winAmount = betAmount * multiplier;
                    balance += winAmount;
                    showResult(true, winAmount - betAmount);
                    addTransaction('Roulette', winAmount - betAmount, 'win');
                } else {
                    showResult(false, betAmount);
                    addTransaction('Roulette', -betAmount, 'loss');
                }

                updateBalance();
            }, 1500);
        }

        // Bomb yard game
        function initBombGrid() {
            const grid = document.getElementById('bombGrid');
            grid.innerHTML = '';

            for (let i = 0; i < 25; i++) {
                const tile = document.createElement('div');
                tile.className = 'bomb-tile';
                tile.onclick = () => pickTile(i);
                grid.appendChild(tile);
            }
        }

        function startBomb() {
            const betAmount = parseFloat(document.getElementById('bombBet').value);

            if (betAmount > balance) {
                alert('Insufficient balance!');
                return;
            }

            balance -= betAmount;
            updateBalance();

            // Initialize game state
            const bombs = [];
            const bombCount = 5; // 20% of 25 tiles
            while (bombs.length < bombCount) {
                const pos = Math.floor(Math.random() * 25);
                if (!bombs.includes(pos)) bombs.push(pos);
            }

            bombGame = {
                bombs: bombs,
                revealed: [],
                betAmount: betAmount,
                multiplier: 1.0,
                picks: 0
            };

            // Reset UI
            initBombGrid();
            document.getElementById('bombPicks').textContent = '0';
            document.getElementById('bombMultiplier').textContent = '1.00x';
            document.getElementById('bombWin').textContent = '0';
            document.getElementById('bombCashout').disabled = true;
            document.getElementById('bombStart').disabled = true;
        }

        function pickTile(index) {
            if (!bombGame || bombGame.revealed.includes(index)) return;

            const tiles = document.querySelectorAll('.bomb-tile');
            const tile = tiles[index];

            // Dynamic Rigging: Reduce win chance by 5%
            const totalTiles = 25;
            const remainingTiles = totalTiles - bombGame.revealed.length;
            const remainingBombs = bombGame.bombs.length; // Always 5 unless we reveal one (game over)

            // Calculate FAIR chance of picking a SAFE tile
            const fairSafeChance = (remainingTiles - remainingBombs) / remainingTiles;

            // RIGGED chance: 5% lower
            // Ensure chance doesn't go below 0
            const riggedSafeChance = Math.max(0, fairSafeChance - 0.05);

            // Determine outcome based on rigged chance
            const forceSafe = Math.random() < riggedSafeChance;

            // Manipulate board state to match forced outcome
            if (forceSafe) {
                // We want a SAFE tile
                if (bombGame.bombs.includes(index)) {
                    // It was a bomb! Move it to a safe unrevealed spot
                    // Find all safe unrevealed indices
                    const safeUnrevealed = [];
                    for (let i = 0; i < 25; i++) {
                        if (!bombGame.revealed.includes(i) && !bombGame.bombs.includes(i) && i !== index) {
                            safeUnrevealed.push(i);
                        }
                    }

                    if (safeUnrevealed.length > 0) {
                        // Pick random safe spot
                        const newBombPos = safeUnrevealed[Math.floor(Math.random() * safeUnrevealed.length)];
                        // Move bomb: remove from current, add to new
                        bombGame.bombs = bombGame.bombs.filter(b => b !== index);
                        bombGame.bombs.push(newBombPos);
                    }
                }
            } else {
                // We want a BOMB (Force Loss)
                if (!bombGame.bombs.includes(index)) {
                    // It was safe! Move a bomb here
                    // Find a bomb at an unrevealed spot to move here
                    // Make sure we pick a bomb that isn't already revealed (shouldn't happen in this logic flow but good safety)
                    const unrevealedBombs = bombGame.bombs.filter(b => !bombGame.revealed.includes(b));

                    if (unrevealedBombs.length > 0) {
                        const bombToMove = unrevealedBombs[0]; // Just take the first one
                        bombGame.bombs = bombGame.bombs.filter(b => b !== bombToMove);
                        bombGame.bombs.push(index);
                    }
                }
            }

            bombGame.revealed.push(index);

            if (bombGame.bombs.includes(index)) {
                // Hit a bomb!
                tile.classList.add('revealed', 'bomb');
                tile.textContent = 'üí£';

                // Game over
                setTimeout(() => {
                    showResult(false, bombGame.betAmount);
                    addTransaction('Mines', -bombGame.betAmount, 'loss');
                    resetBombGame();
                }, 800);
            } else {
                // Safe tile
                tile.classList.add('revealed', 'safe');
                tile.textContent = 'üíé';

                bombGame.picks++;

                // Update multiplier (non-linear growth)
                const multipliers = [1.0, 1.2, 1.5, 1.9, 2.4, 3.0, 3.8, 4.8, 6.0, 7.5, 9.5, 12.0, 15.0, 19.0, 24.0, 30.0, 38.0, 48.0, 60.0, 75.0];
                bombGame.multiplier = multipliers[Math.min(bombGame.picks - 1, multipliers.length - 1)];

                document.getElementById('bombPicks').textContent = bombGame.picks;
                document.getElementById('bombMultiplier').textContent = bombGame.multiplier.toFixed(2) + 'x';
                document.getElementById('bombWin').textContent = Math.ceil(bombGame.betAmount * bombGame.multiplier);
                document.getElementById('bombCashout').disabled = false;
            }
        }

        function cashoutBomb() {
            if (!bombGame) return;

            const winAmount = bombGame.betAmount * bombGame.multiplier;
            balance += winAmount;
            updateBalance();

            showResult(true, winAmount - bombGame.betAmount);
            addTransaction('Mines', winAmount - bombGame.betAmount, 'win');
            resetBombGame();
        }

        function resetBombGame() {
            bombGame = null;
            document.getElementById('bombStart').disabled = false;
            document.getElementById('bombCashout').disabled = true;
            initBombGrid();
            document.getElementById('bombPicks').textContent = '0';
            document.getElementById('bombMultiplier').textContent = '1.00x';
            document.getElementById('bombWin').textContent = '0';
        }

        // Result modal
        function showResult(isWin, amount) {
            const modal = document.getElementById('resultModal');
            const emoji = document.getElementById('resultEmoji');
            const title = document.getElementById('resultTitle');
            const amountEl = document.getElementById('resultAmount');

            if (isWin) {
                emoji.textContent = 'üéâ';
                title.textContent = currentLanguage === 'en' ? 'You Won!' : '–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!';
                amountEl.textContent = '+' + Math.ceil(amount) + ' ü™ô';
                amountEl.className = 'result-amount win';
            } else {
                emoji.textContent = 'üò¢';
                title.textContent = currentLanguage === 'en' ? 'You Lost' : '–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏';
                amountEl.textContent = '-' + Math.ceil(amount) + ' ü™ô';
                amountEl.className = 'result-amount lose';
            }

            modal.classList.add('active');
        }

        function closeResult() {
            document.getElementById('resultModal').classList.remove('active');
        }

        // Copy referral code
        function copyReferralCode() {
            const code = 'https://casino.example/ref/LUCKY777';
            navigator.clipboard.writeText(code).then(() => {
                alert(currentLanguage === 'en' ? 'Referral link copied!' : '–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!');
            });
        }

        // =========== MERSION GAME ===========
        let mersionState = null;
        let mersionSelectedStation = null;
        let mersionAnimFrame = null;

        // Stations: more fish = more encounters = more variance & risk
        // No fixed multiplier ‚Äî outcome is purely from fish collisions
        const MERSION_ZONES = [
            { id: 1, depth: 200, fishCount: 4 },
            { id: 2, depth: 500, fishCount: 7 },
            { id: 3, depth: 1000, fishCount: 10 },
            { id: 4, depth: 3000, fishCount: 14 },
            { id: 5, depth: 6000, fishCount: 18 }
        ];

        // Fish multiplier pools per depth tier
        // House edge: more x0.5 / x0.3 fish than x2 / x3 fish
        // Shallow: mild multipliers, slight house edge
        // Deep: extreme multipliers, bigger house edge
        // Fish pools ‚Äî weighted avg mult < 1.0 so house always wins long-term
        // Shallow avg=0.97/fish ‚Üí 4 fish ‚âà 88% return (12% edge)
        // Mid avg=0.95/fish ‚Üí 7 fish ‚âà 70%, 10 fish ‚âà 60%
        // Deep avg=0.93/fish ‚Üí 14 fish ‚âà 36%, 18 fish ‚âà 27%
        // ============================================================
        // CASINO MATH ‚Äî Balanced fish pools (Monte Carlo verified)
        //
        // Per-fish weighted avg mult < 1.0 ‚Üí house always wins long-term
        // But close enough to 1.0 that players WIN 13-35% of the time
        //
        // Zone 1 (4 fish,  Pool 0): 96% RTP,  4% edge, 35% win rate
        // Zone 2 (7 fish,  Pool 0): 93% RTP,  7% edge, 31% win rate
        // Zone 3 (10 fish, Pool 1): 88% RTP, 12% edge, 24% win rate
        // Zone 4 (14 fish, Pool 1): 85% RTP, 15% edge, 21% win rate
        // Zone 5 (18 fish, Pool 2): 75% RTP, 25% edge, 13% win rate
        //
        // Deeper = more fish encounters = more compounding risk
        // but also higher variance ‚Üí rare big jackpots possible
        // ============================================================
        const FISH_POOLS = [
            {   // Pool 0 ‚Äî Shallow Reef (avg=0.990/fish)
                // Conservative: max x2.0, gentle losses
                fish: [
                    { emoji: 'ü¶à', label: 'x2.0', mult: 2.0, weight: 3 },
                    { emoji: 'üê†', label: 'x1.5', mult: 1.5, weight: 8 },
                    { emoji: 'üê¨', label: 'x1.3', mult: 1.3, weight: 12 },
                    { emoji: 'üêü', label: 'x1.1', mult: 1.1, weight: 16 },
                    { emoji: 'ü™∏', label: 'x0.95', mult: 0.95, weight: 14 },
                    { emoji: 'ü¶Ä', label: 'x0.85', mult: 0.85, weight: 48 },
                    { emoji: 'ü¶ë', label: 'x0.7', mult: 0.7, weight: 10 },
                    { emoji: 'üê°', label: 'x0.5', mult: 0.5, weight: 5 },
                ]
            },
            {   // Pool 1 ‚Äî Twilight Zone (avg=0.988/fish)
                // Moderate: x2.5 possible, bigger swings
                fish: [
                    { emoji: 'üêã', label: 'x2.5', mult: 2.5, weight: 2 },
                    { emoji: 'ü¶à', label: 'x2.0', mult: 2.0, weight: 5 },
                    { emoji: 'üê†', label: 'x1.5', mult: 1.5, weight: 9 },
                    { emoji: 'üê¨', label: 'x1.3', mult: 1.3, weight: 11 },
                    { emoji: 'üêü', label: 'x1.1', mult: 1.1, weight: 14 },
                    { emoji: 'ü™∏', label: 'x0.9', mult: 0.9, weight: 15 },
                    { emoji: 'ü¶Ä', label: 'x0.8', mult: 0.8, weight: 58 },
                    { emoji: 'ü¶ë', label: 'x0.6', mult: 0.6, weight: 8 },
                    { emoji: 'üê°', label: 'x0.4', mult: 0.4, weight: 4 },
                ]
            },
            {   // Pool 2 ‚Äî Deep Abyss (avg=0.985/fish)
                // Wild: x3.0 jackpot fish, extreme variance
                fish: [
                    { emoji: 'üêã', label: 'x3.0', mult: 3.0, weight: 3 },
                    { emoji: 'ü¶à', label: 'x2.0', mult: 2.0, weight: 6 },
                    { emoji: 'üê†', label: 'x1.5', mult: 1.5, weight: 9 },
                    { emoji: 'üê¨', label: 'x1.3', mult: 1.3, weight: 10 },
                    { emoji: 'üêü', label: 'x1.1', mult: 1.1, weight: 12 },
                    { emoji: 'ü™∏', label: 'x0.9', mult: 0.9, weight: 12 },
                    { emoji: 'ü¶Ä', label: 'x0.75', mult: 0.75, weight: 53 },
                    { emoji: 'ü¶ë', label: 'x0.5', mult: 0.5, weight: 9 },
                    { emoji: 'ü™º', label: 'x0.3', mult: 0.3, weight: 5 },
                ]
            }
        ];

        function getPoolForZone(zoneId) {
            if (zoneId <= 2) return FISH_POOLS[0];  // Zones 1-2: Shallow
            if (zoneId <= 4) return FISH_POOLS[1];  // Zones 3-4: Mid
            return FISH_POOLS[2];                    // Zone 5: Deep
        }

        function pickWeightedFish(pool) {
            const totalWeight = pool.fish.reduce((s, f) => s + f.weight, 0);
            let r = Math.random() * totalWeight;
            for (const f of pool.fish) {
                r -= f.weight;
                if (r <= 0) return f;
            }
            return pool.fish[pool.fish.length - 1];
        }

        function selectStation(stationId) {
            mersionSelectedStation = stationId;
            document.querySelectorAll('.mersion-station').forEach(el => el.classList.remove('selected'));
            document.querySelector(`.mersion-station[data-station="${stationId}"]`).classList.add('selected');
        }

        function mersionBack() {
            if (mersionState && mersionState.running) return; // can't leave mid-dive
            resetMersion();
            showScreen('gamesScreen');
        }

        function startMersion() {
            if (!mersionSelectedStation) {
                alert(currentLanguage === 'en' ? 'Select a target zone!' : '–í—ã–±–µ—Ä–∏—Ç–µ –∑–æ–Ω—É!');
                return;
            }

            const betAmount = parseFloat(document.getElementById('mersionBet').value);
            if (!betAmount || betAmount <= 0 || betAmount > balance) {
                alert('Insufficient balance!');
                return;
            }

            balance -= betAmount;
            updateBalance();

            const zone = MERSION_ZONES[mersionSelectedStation - 1];
            const pool = getPoolForZone(zone.id);

            // Pre-generate which fish will appear and their collision timing
            const fishList = [];
            for (let i = 0; i < zone.fishCount; i++) {
                fishList.push({
                    ...pickWeightedFish(pool),
                    hit: false,
                    // Each fish spawns at a different depth fraction
                    spawnAt: (i + 0.5) / zone.fishCount
                });
            }

            mersionState = {
                betAmount,
                coins: betAmount,
                zone,
                pool,
                fishList,
                running: true,
                depth: 0,
                targetDepth: zone.depth,
                hits: 0,
                // Canvas state
                bubbles: [],
                activeFish: [], // fish currently on screen
                nextFishIdx: 0,
                subX: 0,
                subY: 0,
                flashTimer: 0,
                flashColor: null,
                startTime: 0,
                duration: 3000 + zone.fishCount * 800 // total dive time in ms
            };

            document.getElementById('mersionSetup').style.display = 'none';
            document.getElementById('mersionDive').style.display = 'block';
            document.getElementById('mersionCoins').textContent = Math.ceil(betAmount);
            document.getElementById('mersionDepth').textContent = '0m';
            document.getElementById('mersionHits').textContent = '0';
            document.getElementById('mersionProgress').style.width = '0%';
            document.getElementById('mersionLog').innerHTML = '';

            initMersionCanvas();
        }

        function initMersionCanvas() {
            const canvas = document.getElementById('mersionCanvas');
            const container = document.getElementById('mersionOcean');
            const W = container.offsetWidth;
            const H = Math.min(440, Math.floor(W * 0.95));
            const dpr = window.devicePixelRatio || 1;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';

            const s = mersionState;
            s.canvasW = W * dpr;
            s.canvasH = H * dpr;
            s.dpr = dpr;
            s.subX = s.canvasW * 0.5;
            s.subY = s.canvasH * 0.38;

            // Bubbles ‚Äî lots of them
            s.bubbles = [];
            for (let i = 0; i < 40; i++) {
                s.bubbles.push({
                    x: Math.random() * s.canvasW,
                    y: Math.random() * s.canvasH,
                    r: (1 + Math.random() * 4) * dpr,
                    speed: (0.2 + Math.random() * 0.8) * dpr,
                    opacity: 0.05 + Math.random() * 0.15,
                    wobble: Math.random() * Math.PI * 2
                });
            }

            // Decorative background fish ‚Äî lots swimming randomly
            s.bgFish = [];
            for (let i = 0; i < 28; i++) {
                const size = (5 + Math.random() * 14) * dpr;
                const dir = Math.random() > 0.5 ? 1 : -1;
                const hue = Math.random() > 0.5
                    ? (160 + Math.random() * 60)  // teal/cyan
                    : (30 + Math.random() * 30);    // orange/gold
                s.bgFish.push({
                    x: Math.random() * s.canvasW,
                    y: 40 * dpr + Math.random() * (s.canvasH - 120 * dpr),
                    size: size,
                    speed: (0.2 + Math.random() * 0.9) * dpr * dir,
                    vy: (Math.random() - 0.5) * 0.3 * dpr,
                    wobbleAmp: 0.5 + Math.random() * 2,
                    wobbleFreq: 0.003 + Math.random() * 0.005,
                    wobbleOffset: Math.random() * 1000,
                    opacity: 0.08 + Math.random() * 0.18,
                    hue: hue,
                    tailPhase: Math.random() * Math.PI * 2
                });
            }

            // Ancient city structures (generated once)
            s.cityStructures = generateAncientCity(s.canvasW, s.canvasH, dpr);

            s.startTime = performance.now();
            mersionAnimFrame = requestAnimationFrame(mersionGameLoop);
        }

        function generateAncientCity(W, H, dpr) {
            const structs = [];
            const baseY = H - 10 * dpr;

            // Temple with columns (center-ish)
            const templeX = W * 0.5 + (Math.random() - 0.5) * W * 0.2;
            structs.push({
                type: 'temple',
                x: templeX, y: baseY,
                w: 90 * dpr, h: 70 * dpr,
                columns: 5, colW: 6 * dpr, roofH: 12 * dpr
            });

            // Tall broken column (left)
            structs.push({
                type: 'column',
                x: W * 0.12, y: baseY,
                w: 10 * dpr, h: (50 + Math.random() * 30) * dpr,
                broken: true
            });

            // Arch (right side)
            structs.push({
                type: 'arch',
                x: W * 0.78, y: baseY,
                w: 50 * dpr, h: 55 * dpr, archR: 20 * dpr
            });

            // Small ruins left
            structs.push({
                type: 'ruin',
                x: W * 0.28, y: baseY,
                blocks: [
                    { dx: 0, dy: 0, w: 20 * dpr, h: 15 * dpr },
                    { dx: 22 * dpr, dy: 0, w: 12 * dpr, h: 25 * dpr },
                    { dx: 8 * dpr, dy: -16 * dpr, w: 14 * dpr, h: 10 * dpr },
                ]
            });

            // Tall pillar right of center
            structs.push({
                type: 'column',
                x: W * 0.63, y: baseY,
                w: 8 * dpr, h: 60 * dpr,
                broken: false
            });

            // Small column cluster far right
            structs.push({
                type: 'ruin',
                x: W * 0.9, y: baseY,
                blocks: [
                    { dx: 0, dy: 0, w: 8 * dpr, h: 35 * dpr },
                    { dx: 14 * dpr, dy: 0, w: 8 * dpr, h: 22 * dpr },
                    { dx: -12 * dpr, dy: 0, w: 10 * dpr, h: 18 * dpr },
                ]
            });

            // Pyramid shape far left
            structs.push({ type: 'pyramid', x: W * 0.05, y: baseY, w: 60 * dpr, h: 40 * dpr });

            return structs;
        }

        function mersionGameLoop(timestamp) {
            const s = mersionState;
            if (!s || !s.running) return;

            const elapsed = timestamp - s.startTime;
            const progress = Math.min(1, elapsed / s.duration);

            // Update depth
            s.depth = Math.floor(s.targetDepth * progress);
            document.getElementById('mersionDepth').textContent = s.depth + 'm';
            document.getElementById('mersionProgress').style.width = (progress * 100) + '%';

            // Spawn fish at their scheduled depth
            while (s.nextFishIdx < s.fishList.length && progress >= s.fishList[s.nextFishIdx].spawnAt) {
                spawnMersionFish(s.fishList[s.nextFishIdx]);
                s.nextFishIdx++;
            }

            // Update & draw
            updateMersionFish();
            drawMersionFrame(progress);

            // Flash decay
            if (s.flashTimer > 0) s.flashTimer -= 16;

            if (progress < 1) {
                mersionAnimFrame = requestAnimationFrame(mersionGameLoop);
            } else {
                // Dive complete ‚Äî wait for remaining fish to clear
                s.running = false;
                finishMersionDive();
            }
        }

        function spawnMersionFish(fishData) {
            const s = mersionState;
            const fromLeft = Math.random() > 0.5;
            const fishObj = {
                ...fishData,
                x: fromLeft ? -60 * s.dpr : s.canvasW + 60 * s.dpr,
                y: (80 + Math.random() * (s.canvasH - 160)),
                vx: (1.5 + Math.random() * 2.5) * s.dpr * (fromLeft ? 1 : -1),
                vy: (Math.random() - 0.5) * 1.2 * s.dpr,
                size: (22 + Math.random() * 12) * s.dpr,
                hit: false,
                alive: true
            };
            s.activeFish.push(fishObj);
        }

        function updateMersionFish() {
            const s = mersionState;
            const subR = 32 * s.dpr; // submarine collision radius

            for (let i = s.activeFish.length - 1; i >= 0; i--) {
                const f = s.activeFish[i];
                f.x += f.vx;
                f.y += f.vy;

                // Bounce off top/bottom
                if (f.y < 30 * s.dpr || f.y > s.canvasH - 30 * s.dpr) {
                    f.vy *= -1;
                }

                // Check collision with sub
                if (!f.hit) {
                    const dx = f.x - s.subX;
                    const dy = f.y - s.subY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < subR + f.size * 0.6) {
                        // COLLISION!
                        f.hit = true;
                        applyFishHit(f);
                    }
                }

                // Remove if off screen
                if (f.x < -100 * s.dpr || f.x > s.canvasW + 100 * s.dpr) {
                    // If fish went through without hitting, it just passes
                    s.activeFish.splice(i, 1);
                }
            }
        }

        function applyFishHit(fish) {
            const s = mersionState;
            const oldCoins = s.coins;
            s.coins = Math.round(s.coins * fish.mult);
            s.hits++;

            const diff = s.coins - oldCoins;
            const isGood = fish.mult >= 1;

            // Flash effect
            s.flashTimer = 300;
            s.flashColor = isGood ? 'rgba(0,232,123,0.15)' : 'rgba(255,71,87,0.15)';

            // Update HUD
            document.getElementById('mersionCoins').textContent = Math.max(0, Math.ceil(s.coins));
            document.getElementById('mersionCoins').style.color = isGood ? 'var(--accent)' : 'var(--error)';
            setTimeout(() => {
                const el = document.getElementById('mersionCoins');
                if (el) el.style.color = 'var(--accent)';
            }, 400);
            document.getElementById('mersionHits').textContent = s.hits;

            // Log entry
            const log = document.getElementById('mersionLog');
            const entry = document.createElement('div');
            entry.className = 'mersion-log-entry';
            const cls = isGood ? 'mersion-log-positive' : 'mersion-log-negative';
            const sign = diff >= 0 ? '+' : '';
            entry.innerHTML = `<span>${fish.emoji} ${fish.label}</span><span class="${cls}">${sign}${Math.ceil(diff)}</span>`;
            log.prepend(entry);

            // Check if coins hit zero
            if (s.coins <= 0) {
                s.coins = 0;
                s.running = false;
                document.getElementById('mersionCoins').textContent = '0';
                setTimeout(() => {
                    cancelAnimationFrame(mersionAnimFrame);
                    showResult(false, s.betAmount);
                    addTransaction('Mersion', -s.betAmount, 'loss');
                    updateBalance();
                    resetMersion();
                }, 600);
            }
        }

        // === Draw a proper fish shape ===
        function drawFishShape(ctx, size, bodyColor, alpha) {
            const s = size;
            ctx.globalAlpha = alpha;

            // Body ‚Äî curved fish shape using bezier
            ctx.beginPath();
            ctx.moveTo(s * 0.6, 0);
            ctx.bezierCurveTo(s * 0.6, -s * 0.35, s * 0.1, -s * 0.45, -s * 0.3, -s * 0.25);
            ctx.bezierCurveTo(-s * 0.6, -s * 0.12, -s * 0.7, 0, -s * 0.6, s * 0.12);
            ctx.bezierCurveTo(-s * 0.3, s * 0.25, s * 0.1, s * 0.45, s * 0.6, 0);
            ctx.closePath();
            ctx.fillStyle = bodyColor;
            ctx.fill();

            // Tail fin
            const tailWag = Math.sin(Date.now() * 0.012 + size * 10) * s * 0.08;
            ctx.beginPath();
            ctx.moveTo(-s * 0.55, 0);
            ctx.lineTo(-s * 0.95 + tailWag, -s * 0.32);
            ctx.quadraticCurveTo(-s * 0.75, 0, -s * 0.95 - tailWag, s * 0.32);
            ctx.closePath();
            ctx.fillStyle = bodyColor;
            ctx.fill();

            // Dorsal fin (top)
            ctx.beginPath();
            ctx.moveTo(s * 0.1, -s * 0.35);
            ctx.quadraticCurveTo(-s * 0.1, -s * 0.55, -s * 0.35, -s * 0.3);
            ctx.closePath();
            ctx.fillStyle = bodyColor;
            ctx.globalAlpha = alpha * 0.7;
            ctx.fill();
            ctx.globalAlpha = alpha;

            // Belly highlight
            ctx.beginPath();
            ctx.ellipse(s * 0.05, s * 0.08, s * 0.35, s * 0.12, 0, 0, Math.PI);
            ctx.fillStyle = `rgba(255,255,255,0.15)`;
            ctx.fill();

            // Eye
            ctx.beginPath();
            ctx.arc(s * 0.32, -s * 0.08, s * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,255,255,0.9)`;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.35, -s * 0.08, s * 0.05, 0, Math.PI * 2);
            ctx.fillStyle = '#111';
            ctx.fill();

            ctx.globalAlpha = 1;
        }

        function drawMersionFrame(progress) {
            const s = mersionState;
            const canvas = document.getElementById('mersionCanvas');
            const ctx = canvas.getContext('2d');
            const W = s.canvasW;
            const H = s.canvasH;
            const dpr = s.dpr;
            const now = Date.now();

            // === BACKGROUND ‚Äî ocean gradient, gets darker with depth ===
            const d = progress;
            const grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, `rgb(${Math.floor(6 - d * 4)},${Math.floor(25 - d * 18)},${Math.floor(65 - d * 30)})`);
            grad.addColorStop(0.7, `rgb(${Math.max(0, Math.floor(3 - d * 3))},${Math.max(0, Math.floor(12 - d * 10))},${Math.max(0, Math.floor(40 - d * 25))})`);
            grad.addColorStop(1, `rgb(${Math.max(0, Math.floor(2 - d * 2))},${Math.max(0, Math.floor(8 - d * 6))},${Math.max(0, Math.floor(25 - d * 15))})`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Subtle light rays from surface
            if (progress < 0.7) {
                ctx.save();
                ctx.globalAlpha = 0.03 * (1 - progress);
                for (let r = 0; r < 5; r++) {
                    const rx = W * (0.15 + r * 0.18);
                    ctx.beginPath();
                    ctx.moveTo(rx, 0);
                    ctx.lineTo(rx + 30 * dpr, H * 0.7);
                    ctx.lineTo(rx - 20 * dpr, H * 0.7);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(100,200,255,0.5)';
                    ctx.fill();
                }
                ctx.restore();
            }

            // Flash overlay
            if (s.flashTimer > 0) {
                ctx.fillStyle = s.flashColor;
                ctx.fillRect(0, 0, W, H);
            }

            // === ANCIENT CITY (background) ===
            drawAncientCity(ctx, s, progress);

            // === BUBBLES ===
            s.bubbles.forEach(b => {
                b.wobble += 0.02;
                b.y -= b.speed;
                b.x += Math.sin(b.wobble) * 0.3 * dpr;
                if (b.y < -10) { b.y = H + 10; b.x = Math.random() * W; }
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(140,210,255,${b.opacity})`;
                ctx.fill();
                // Bubble highlight
                ctx.beginPath();
                ctx.arc(b.x - b.r * 0.25, b.y - b.r * 0.25, b.r * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${b.opacity * 0.5})`;
                ctx.fill();
            });

            // Depth particles drifting up
            const pCount = Math.floor(8 + progress * 35);
            for (let i = 0; i < pCount; i++) {
                const px = ((i * 137.5 + now * 0.008) % W);
                const py = ((i * 97.3 + now * 0.025) % H);
                ctx.fillStyle = `rgba(80,160,200,${0.03 + progress * 0.06})`;
                ctx.fillRect(px, py, 1.2 * dpr, 1.2 * dpr);
            }

            // === BACKGROUND DECORATIVE FISH (many!) ===
            s.bgFish.forEach(f => {
                f.x += f.speed;
                f.y += f.vy + Math.sin(now * f.wobbleFreq + f.wobbleOffset) * f.wobbleAmp * 0.15 * dpr;
                f.tailPhase += 0.08;

                // Wrap around
                if (f.speed > 0 && f.x > W + f.size * 3) { f.x = -f.size * 3; f.y = 40 * dpr + Math.random() * (H - 120 * dpr); }
                if (f.speed < 0 && f.x < -f.size * 3) { f.x = W + f.size * 3; f.y = 40 * dpr + Math.random() * (H - 120 * dpr); }
                if (f.y < 20 * dpr) f.y = 20 * dpr;
                if (f.y > H - 60 * dpr) f.y = H - 60 * dpr;

                const dir = f.speed > 0 ? 1 : -1;
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.scale(dir, 1);

                const clr = `hsla(${f.hue}, 50%, 55%, 1)`;
                drawFishShape(ctx, f.size, clr, f.opacity);

                ctx.restore();
            });

            // === ACTIVE MULTIPLIER FISH (game fish) ===
            s.activeFish.forEach(f => {
                if (!f.alive) return;
                const dir = f.vx > 0 ? 1 : -1;
                const isGood = f.mult >= 1;
                const alpha = f.hit ? 0.25 : 0.85;

                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.scale(dir, 1);

                // Glow behind multiplier fish
                if (!f.hit) {
                    ctx.beginPath();
                    ctx.arc(0, 0, f.size * 1.2, 0, Math.PI * 2);
                    ctx.fillStyle = isGood ? 'rgba(0,232,123,0.08)' : 'rgba(255,71,87,0.08)';
                    ctx.fill();
                }

                const bodyColor = isGood
                    ? `rgba(0,210,130,1)`
                    : `rgba(240,70,70,1)`;
                drawFishShape(ctx, f.size, bodyColor, alpha);

                ctx.restore();

                // Multiplier label (always upright)
                if (!f.hit) {
                    ctx.save();
                    const fontSize = Math.max(10, Math.floor(f.size * 0.4 / dpr));
                    ctx.font = `900 ${fontSize * dpr}px Syne, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const text = f.label;
                    const tw = ctx.measureText(text).width + 10 * dpr;
                    const th = fontSize * dpr + 6 * dpr;
                    const lx = f.x;
                    const ly = f.y - f.size * 0.65 - 6 * dpr;

                    // Pill background
                    ctx.fillStyle = isGood ? 'rgba(0,180,100,0.9)' : 'rgba(200,40,40,0.9)';
                    ctx.beginPath();
                    ctx.roundRect(lx - tw / 2, ly - th / 2, tw, th, 5 * dpr);
                    ctx.fill();
                    ctx.strokeStyle = isGood ? 'rgba(0,255,140,0.4)' : 'rgba(255,100,100,0.4)';
                    ctx.lineWidth = 1 * dpr;
                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    ctx.fillText(text, lx, ly + 1 * dpr);
                    ctx.restore();
                }
            });

            // === SUBMARINE ===
            const subX = s.subX;
            const subY = s.subY;
            const sc = dpr;

            // Light beam below sub
            ctx.save();
            ctx.globalAlpha = 0.03 + 0.02 * Math.sin(now * 0.002);
            ctx.beginPath();
            ctx.moveTo(subX + 12 * sc, subY + 16 * sc);
            ctx.lineTo(subX + 70 * sc, subY + 140 * sc);
            ctx.lineTo(subX - 45 * sc, subY + 140 * sc);
            ctx.closePath();
            ctx.fillStyle = '#aaddff';
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.translate(subX, subY);

            // Hull glow
            ctx.beginPath();
            ctx.ellipse(0, 0, 38 * sc, 22 * sc, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(60,140,220,0.07)';
            ctx.fill();

            // Main hull
            ctx.beginPath();
            ctx.ellipse(0, 0, 32 * sc, 16 * sc, 0, 0, Math.PI * 2);
            const hullGrad = ctx.createLinearGradient(0, -16 * sc, 0, 16 * sc);
            hullGrad.addColorStop(0, '#6aacec');
            hullGrad.addColorStop(0.5, '#4a8fd0');
            hullGrad.addColorStop(1, '#2d6fa8');
            ctx.fillStyle = hullGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(160,220,255,0.5)';
            ctx.lineWidth = 1.5 * sc;
            ctx.stroke();

            // Hull stripe
            ctx.beginPath();
            ctx.ellipse(0, 2 * sc, 28 * sc, 4 * sc, 0, 0, Math.PI);
            ctx.fillStyle = 'rgba(255,200,50,0.25)';
            ctx.fill();

            // Conning tower
            ctx.beginPath();
            ctx.moveTo(-6 * sc, -14 * sc);
            ctx.lineTo(-4 * sc, -26 * sc);
            ctx.lineTo(4 * sc, -26 * sc);
            ctx.lineTo(6 * sc, -14 * sc);
            ctx.closePath();
            ctx.fillStyle = '#3a88b8';
            ctx.fill();
            ctx.strokeStyle = 'rgba(160,220,255,0.4)';
            ctx.lineWidth = 1 * sc;
            ctx.stroke();

            // Periscope
            ctx.beginPath();
            ctx.moveTo(0, -26 * sc);
            ctx.lineTo(0, -33 * sc);
            ctx.lineTo(5 * sc, -33 * sc);
            ctx.strokeStyle = 'rgba(140,200,240,0.6)';
            ctx.lineWidth = 1.5 * sc;
            ctx.stroke();

            // Viewport window
            ctx.beginPath();
            ctx.arc(12 * sc, -1 * sc, 9 * sc, 0, Math.PI * 2);
            const winGrad = ctx.createRadialGradient(11 * sc, -3 * sc, 2 * sc, 12 * sc, -1 * sc, 9 * sc);
            winGrad.addColorStop(0, 'rgba(200,250,255,0.8)');
            winGrad.addColorStop(1, 'rgba(100,200,240,0.5)');
            ctx.fillStyle = winGrad;
            ctx.fill();
            ctx.strokeStyle = 'rgba(220,250,255,0.7)';
            ctx.lineWidth = 1.5 * sc;
            ctx.stroke();

            // Small window
            ctx.beginPath();
            ctx.arc(-8 * sc, 2 * sc, 4 * sc, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(150,230,255,0.5)';
            ctx.fill();

            // Propeller
            const pPhase = now * 0.015;
            for (let b = 0; b < 3; b++) {
                const angle = pPhase + b * (Math.PI * 2 / 3);
                ctx.save();
                ctx.translate(-34 * sc, 0);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.ellipse(0, 5 * sc, 2 * sc, 5 * sc, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(180,220,240,0.4)';
                ctx.fill();
                ctx.restore();
            }
            // Propeller hub
            ctx.beginPath();
            ctx.arc(-34 * sc, 0, 3 * sc, 0, Math.PI * 2);
            ctx.fillStyle = '#4a8fd0';
            ctx.fill();

            // Propeller wash
            ctx.beginPath();
            ctx.ellipse(-42 * sc, 0, 8 * sc, 5 * sc, 0, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0,232,123,${0.08 + Math.sin(pPhase * 2) * 0.05})`;
            ctx.fill();

            ctx.restore();

            // === COIN TEXT ON SUB ===
            ctx.save();
            ctx.font = `800 ${12 * dpr}px Syne, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.7)';
            ctx.shadowBlur = 5 * dpr;
            ctx.fillStyle = '#fff';
            ctx.fillText(Math.max(0, Math.ceil(s.coins)) + '', subX, subY + 1 * dpr);
            ctx.restore();
        }

        // === Draw ancient underwater city ===
        function drawAncientCity(ctx, s, progress) {
            const W = s.canvasW;
            const H = s.canvasH;
            const dpr = s.dpr;

            // City only becomes visible as you descend
            const cityAlpha = Math.min(0.2, progress * 0.3);
            if (cityAlpha < 0.01) return;

            ctx.save();
            ctx.globalAlpha = cityAlpha;

            const baseColor = `rgba(60,90,110,1)`;
            const highlightColor = `rgba(80,130,150,1)`;

            s.cityStructures.forEach(st => {
                if (st.type === 'temple') {
                    // Floor
                    ctx.fillStyle = baseColor;
                    ctx.fillRect(st.x - st.w / 2, st.y - 5 * dpr, st.w, 5 * dpr);
                    // Columns
                    const spacing = st.w / (st.columns + 1);
                    for (let c = 1; c <= st.columns; c++) {
                        const cx = st.x - st.w / 2 + spacing * c;
                        ctx.fillStyle = highlightColor;
                        ctx.fillRect(cx - st.colW / 2, st.y - st.h, st.colW, st.h - 5 * dpr);
                        // Column cap
                        ctx.fillRect(cx - st.colW * 0.8, st.y - st.h, st.colW * 1.6, 4 * dpr);
                    }
                    // Triangular roof
                    ctx.beginPath();
                    ctx.moveTo(st.x - st.w / 2 - 5 * dpr, st.y - st.h);
                    ctx.lineTo(st.x, st.y - st.h - st.roofH);
                    ctx.lineTo(st.x + st.w / 2 + 5 * dpr, st.y - st.h);
                    ctx.closePath();
                    ctx.fillStyle = baseColor;
                    ctx.fill();
                    // Roof edge
                    ctx.fillStyle = highlightColor;
                    ctx.fillRect(st.x - st.w / 2 - 5 * dpr, st.y - st.h - 2 * dpr, st.w + 10 * dpr, 3 * dpr);
                }

                if (st.type === 'column') {
                    ctx.fillStyle = highlightColor;
                    ctx.fillRect(st.x - st.w / 2, st.y - st.h, st.w, st.h);
                    // Cap
                    ctx.fillRect(st.x - st.w, st.y - st.h, st.w * 2, 4 * dpr);
                    if (st.broken) {
                        // Jagged broken top
                        ctx.fillStyle = baseColor;
                        ctx.beginPath();
                        ctx.moveTo(st.x - st.w, st.y - st.h);
                        ctx.lineTo(st.x - st.w * 0.3, st.y - st.h - 6 * dpr);
                        ctx.lineTo(st.x + st.w * 0.5, st.y - st.h - 2 * dpr);
                        ctx.lineTo(st.x + st.w, st.y - st.h);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Ornate cap
                        ctx.fillRect(st.x - st.w * 1.2, st.y - st.h - 3 * dpr, st.w * 2.4, 3 * dpr);
                    }
                    // Base
                    ctx.fillRect(st.x - st.w * 1.1, st.y - 4 * dpr, st.w * 2.2, 4 * dpr);
                }

                if (st.type === 'arch') {
                    ctx.fillStyle = highlightColor;
                    // Left pillar
                    ctx.fillRect(st.x - st.w / 2, st.y - st.h, 6 * dpr, st.h);
                    // Right pillar
                    ctx.fillRect(st.x + st.w / 2 - 6 * dpr, st.y - st.h, 6 * dpr, st.h);
                    // Arch curve
                    ctx.beginPath();
                    ctx.arc(st.x, st.y - st.h + st.archR, st.archR, Math.PI, 0);
                    ctx.lineWidth = 5 * dpr;
                    ctx.strokeStyle = highlightColor;
                    ctx.stroke();
                    // Keystone
                    ctx.fillRect(st.x - 4 * dpr, st.y - st.h, 8 * dpr, 8 * dpr);
                }

                if (st.type === 'ruin') {
                    st.blocks.forEach(bl => {
                        ctx.fillStyle = highlightColor;
                        ctx.fillRect(st.x + bl.dx, st.y - bl.h + bl.dy, bl.w, bl.h);
                    });
                }

                if (st.type === 'pyramid') {
                    ctx.beginPath();
                    ctx.moveTo(st.x, st.y);
                    ctx.lineTo(st.x + st.w / 2, st.y - st.h);
                    ctx.lineTo(st.x + st.w, st.y);
                    ctx.closePath();
                    ctx.fillStyle = baseColor;
                    ctx.fill();
                    // Step lines
                    const steps = 4;
                    for (let i = 1; i < steps; i++) {
                        const sy = st.y - st.h * (i / steps);
                        const sw = st.w * (1 - i / steps);
                        const sx = st.x + (st.w - sw) / 2;
                        ctx.fillStyle = highlightColor;
                        ctx.fillRect(sx, sy, sw, 1.5 * dpr);
                    }
                }
            });

            // Sea floor ground line
            ctx.fillStyle = 'rgba(50,80,100,0.6)';
            ctx.fillRect(0, H - 10 * dpr, W, 10 * dpr);

            // Seaweed patches
            for (let i = 0; i < 12; i++) {
                const sx = (i * W / 12) + 10 * dpr;
                const sh = (15 + Math.random() * 20) * dpr;
                const sway = Math.sin(Date.now() * 0.002 + i * 1.5) * 4 * dpr;
                ctx.beginPath();
                ctx.moveTo(sx, H - 10 * dpr);
                ctx.quadraticCurveTo(sx + sway, H - 10 * dpr - sh * 0.6, sx + sway * 0.5, H - 10 * dpr - sh);
                ctx.strokeStyle = 'rgba(40,120,80,0.6)';
                ctx.lineWidth = 2 * dpr;
                ctx.stroke();
            }

            ctx.restore();
        }

        async function finishMersionDive() {
            const s = mersionState;
            if (!s) return;

            // Wait a beat for any remaining on-screen fish to finish
            await new Promise(r => setTimeout(r, 800));

            cancelAnimationFrame(mersionAnimFrame);

            const finalCoins = Math.max(0, Math.ceil(s.coins));

            if (finalCoins <= 0) {
                // Already handled in applyFishHit
                if (mersionState) {
                    showResult(false, s.betAmount);
                    addTransaction('Mersion', -s.betAmount, 'loss');
                    updateBalance();
                    resetMersion();
                }
                return;
            }

            // Payout is simply the remaining coins in the sub
            balance += finalCoins;
            updateBalance();

            const profit = finalCoins - s.betAmount;
            if (profit >= 0) {
                showResult(true, profit);
                addTransaction('Mersion', profit, 'win');
            } else {
                showResult(false, Math.abs(profit));
                addTransaction('Mersion', profit, 'loss');
            }

            resetMersion();
        }

        function resetMersion() {
            if (mersionAnimFrame) cancelAnimationFrame(mersionAnimFrame);
            mersionState = null;
            mersionSelectedStation = null;

            document.getElementById('mersionSetup').style.display = 'block';
            document.getElementById('mersionDive').style.display = 'none';
            document.querySelectorAll('.mersion-station').forEach(el => el.classList.remove('selected'));
        }

        // Initialize display
        initBombGrid();
        updateDiceFaces();
        updateBalance();
    </script>
</body>

</html>